#!/usr/bin/env Rscript

library(argparse)
library(dplyr)
library(haven)
library(brms)
library(ggplot2)
library(tidybayes)
library(HDInterval)
library(doParallel)
library(foreach)
library(gtools)
library(parallel)

# Argument parser setup
parser <- ArgumentParser()

parser$add_argument("--mmwrFile", type = "character", help = "MMWR data file")
parser$add_argument("--censusFile_B", type = "character", help = "Bacterial census data file")
parser$add_argument("--censusFile_P", type = "character", help = "Parasitic census data file")
parser$add_argument("--travel", type = "character", help = "Travel types (e.g., NO,UNKNOWN)")
parser$add_argument("--cidt", type = "character", help = "CIDT types (e.g., CIDT+,CX+,PARASITIC)")
parser$add_argument("--projID", type = "character", help = "Project ID")
parser$add_argument("--whichFunctions", type = "character", help = "Path to functions.R")
parser$add_argument("--debug", action = "store_true", default = FALSE, help = "Debug mode")

args <- parser$parse_args()

# Source functions.R from the provided path
source(args$whichFunctions)

# Define outBase based on projID
outBase <- paste0("SplineResults/", args$projID, "_")
dir.create("SplineResults", showWarnings = FALSE)

# Load data using the PATH_ANALYSIS function
mmwrdata <- read_sas(args$mmwrFile)
census_B <- read_sas(args$censusFile_B)
census_P <- read_sas(args$censusFile_P)

# Combine bacterial and parasitic census data
census <- bind_rows(census_B, census_P)

# Perform path analysis
pathDf <- PATH_ANALYSIS(mmwrdata, census, outBase)

# Prepare data for modeling
bact <- pathDf %>%
  filter(culture == "BACTERIAL") %>%
  group_by(pathogen) %>%
  group_split() %>%
  setNames(unique(pathDf$pathogen[pathDf$culture == "BACTERIAL"]))

para <- pathDf %>%
  filter(culture == "PARASITIC") %>%
  group_by(pathogen) %>%
  group_split() %>%
  setNames(unique(pathDf$pathogen[pathDf$culture == "PARASITIC"]))

# Combine bacterial and parasitic data
all_data <- c(bact, para)

# Set up parallel backend
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# Run models in parallel
results <- foreach(
    pathogen_name = names(all_data),
    .combine = 'list',
    .multicombine = TRUE,
    .final = function(x) setNames(x, names(all_data)),
    .packages = c('brms', 'dplyr', 'tidybayes', 'HDInterval', 'tidyr')
) %dopar% {
    # Source functions within the worker node
    source(args$whichFunctions)
    # Get the data for the current pathogen
    data <- all_data[[pathogen_name]]
    if (nrow(data) == 0) {
        warning(paste("No data for pathogen:", pathogen_name))
        return(NULL)
    }
    # Fit the model using PROPOSED_BM function
    proposed <- PROPOSED_BM(data)
    # Save the model
    saveFile <- paste0(outBase, pathogen_name, "_brm.Rds")
    saveRDS(proposed, saveFile)
    return(list(model = proposed, data = data))
}

# Stop parallel backend
stopCluster(cl)

# Further analysis and plotting can be added here

