#!/usr/bin/env Rscript

# trendy.R

library(argparse)
library(dplyr)
library(haven)
library(brms)
library(ggplot2)
library(tidybayes)
library(HDInterval)
# library(doParallel)      # Commented out
# library(foreach)         # Commented out
library(gtools)
library(parallel)

# Set options(width) to prevent errors related to text wrapping
options(width = 80)
print(paste("Option width is set to:", getOption("width")))

# Argument parser setup
parser <- ArgumentParser()

parser$add_argument("--mmwrFile", type = "character", help = "MMWR data file")
parser$add_argument("--censusFile_B", type = "character", help = "Bacterial census data file")
parser$add_argument("--censusFile_P", type = "character", help = "Parasitic census data file")
parser$add_argument("--travel", type = "character", help = "Travel types (e.g., NO,UNKNOWN)")
parser$add_argument("--cidt", type = "character", help = "CIDT types (e.g., CIDT+,CX+,PARASITIC)")
parser$add_argument("--projID", type = "character", help = "Project ID")
parser$add_argument("--whichFunctions", type = "character", help = "Path to functions.R")
parser$add_argument("--debug", action = "store_true", default = FALSE, help = "Debug mode")

args <- parser$parse_args()

# Source functions.R from the provided path
source(args$whichFunctions)

# Define outBase based on projID
outBase <- paste0("SplineResults/", args$projID, "_")
dir.create("SplineResults", showWarnings = FALSE)

# Load data using the PATH_ANALYSIS function
print("Loading MMWR data...")
mmwrdata <- read_sas(args$mmwrFile)
print("Loading Bacterial census data...")
census_B <- read_sas(args$censusFile_B)
print("Loading Parasitic census data...")
census_P <- read_sas(args$censusFile_P)

# Combine bacterial and parasitic census data
print("Combining census data...")
census <- bind_rows(census_B, census_P)

# Perform path analysis
print("Performing PATH_ANALYSIS...")
pathDf <- PATH_ANALYSIS(mmwrdata, census, outBase)

# Debugging: Check columns in pathDf
print("Columns in pathDf:")
print(names(pathDf))

# Prepare data for modeling
print("Preparing data for modeling...")
bact <- pathDf %>%
  filter(Pathogen %in% c("CAMPYLOBACTER", "SALMONELLA", "SHIGELLA", 
                         "STEC", "VIBRIO", "YERSINIA", "STEC O157", "STEC NONO157")) %>%
  group_by(Pathogen) %>%
  split(.$Pathogen)  # Replaced group_split and setNames with split

para <- pathDf %>%
  filter(Pathogen == "LISTERIA") %>%
  group_by(Pathogen) %>%
  split(.$Pathogen)  # Replaced group_split and setNames with split

# Combine bacterial and parasitic data
all_data <- c(bact, para)

# Debugging: Check names of all_data
print("Names of all_data:")
print(names(all_data))

# ---- Commented Out Parallel Backend Setup ----
# # Set up parallel backend
# num_cores <- detectCores() - 1
# cl <- makeCluster(num_cores)
# registerDoParallel(cl)

# # Run models in parallel
# results <- foreach(
#     pathogen_name = names(all_data),
#     .combine = 'list',
#     .multicombine = TRUE,
#     .final = function(x) setNames(x, names(all_data)),
#     .packages = c('brms', 'dplyr', 'tidybayes', 'HDInterval', 'tidyr')
# ) %dopar% {
#     tryCatch({
#         # Source functions within the worker node
#         source(args$whichFunctions)
#         print(paste("functions.R sourced in worker for pathogen:", pathogen_name))
        
#         # Verify that PROPOSED_BM exists
#         if (!exists("PROPOSED_BM")) {
#             stop("Function PROPOSED_BM is not available in the worker environment.")
#         }
        
#         # Get the data for the current pathogen
#         data <- all_data[[pathogen_name]]
#         if (nrow(data) == 0) {
#             warning(paste("No data for pathogen:", pathogen_name))
#             return(NULL)
#         }
        
#         # Fit the model using PROPOSED_BM function
#         proposed <- PROPOSED_BM(data)
        
#         # Save the model
#         saveFile <- paste0(outBase, pathogen_name, "_brm.Rds")
#         saveRDS(proposed, saveFile)
        
#         return(list(model = proposed, data = data))
#     }, error = function(e) {
#         # Capture and display the error
#         message(paste("Error in pathogen:", pathogen_name))
#         message(e)
#         return(NULL)
#     })
# }

# # Stop parallel backend
# stopCluster(cl)

# ---- End of Parallel Backend Setup ----

# ---- Serial Processing Begins Here ----
print("Starting serial model fitting...")

# Initialize results list
results <- list()

# Run models serially using a for loop
for (pathogen_name in names(all_data)) {
    tryCatch({
        # Source functions in the main environment
        source(args$whichFunctions)
        print(paste("functions.R sourced in main for pathogen:", pathogen_name))
        
        # Verify that PROPOSED_BM exists
        if (!exists("PROPOSED_BM")) {
            stop("Function PROPOSED_BM is not available in the main environment.")
        }
        
        # Get the data for the current pathogen
        data <- all_data[[pathogen_name]]
        if (nrow(data) == 0) {
            warning(paste("No data for pathogen:", pathogen_name))
            results[[pathogen_name]] <- NULL
            next
        }
        
        # Fit the model using PROPOSED_BM function
        print(paste("Fitting model for pathogen:", pathogen_name))
        proposed <- PROPOSED_BM(data)
        
        # Save the model
        saveFile <- paste0(outBase, pathogen_name, "_brm.Rds")
        saveRDS(proposed, saveFile)
        
        # Store the result
        results[[pathogen_name]] <- list(model = proposed, data = data)
        
        print(paste("Model fitted and saved for pathogen:", pathogen_name))
    }, error = function(e) {
        # Capture and display the error
        message(paste("Error in pathogen:", pathogen_name))
        message(e)
        results[[pathogen_name]] <- NULL
    })
}
# ---- End of Serial Processing ----

# Further analysis and plotting can be added here

